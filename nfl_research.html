<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFL Team Tiering | Jabari Myles</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        /* Page-specific styles for NFL research */
        .research-hero {
            padding: 100px 0 60px;
            background: linear-gradient(180deg, var(--gray-50) 0%, var(--white) 100%);
            border-bottom: 1px solid var(--gray-200);
        }

        .research-hero h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--navy);
            margin-bottom: 12px;
        }

        .research-hero .subtitle {
            font-size: 1.2rem;
            color: var(--gray-600);
            margin-bottom: 8px;
        }

        .research-hero .meta {
            font-size: 0.95rem;
            color: var(--red);
            font-weight: 500;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--gray-600);
            text-decoration: none;
            font-size: 0.9rem;
            margin-bottom: 24px;
            transition: var(--transition);
        }

        .back-link:hover {
            color: var(--navy);
        }

        /* Methodology content */
        .methodology-section {
            margin-bottom: 48px;
        }

        .methodology-section h3 {
            font-size: 1.35rem;
            font-weight: 600;
            color: var(--navy);
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--gray-200);
        }

        .methodology-section h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--gray-800);
            margin: 24px 0 12px;
        }

        .methodology-section p {
            color: var(--gray-600);
            font-size: 1rem;
            margin-bottom: 16px;
            line-height: 1.7;
        }

        .methodology-section ul, .methodology-section ol {
            color: var(--gray-600);
            margin-bottom: 16px;
            padding-left: 24px;
        }

        .methodology-section li {
            margin-bottom: 8px;
            line-height: 1.6;
        }

        .highlight-box {
            background: var(--gray-50);
            border: 1px solid var(--gray-200);
            border-left: 4px solid var(--navy);
            border-radius: 8px;
            padding: 20px 24px;
            margin: 24px 0;
        }

        .highlight-box.key-insight {
            border-left-color: var(--red);
        }

        .highlight-box p {
            margin-bottom: 0;
        }

        .highlight-box p:not(:last-child) {
            margin-bottom: 12px;
        }

        .formula-box {
            background: var(--gray-50);
            border: 1px solid var(--gray-200);
            border-radius: 8px;
            padding: 20px 24px;
            margin: 20px 0;
            font-family: 'Georgia', serif;
            font-size: 1.05rem;
            overflow-x: auto;
            text-align: center;
        }

        .formula-box.left-align {
            text-align: left;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .formula-box code {
            color: var(--navy);
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 24px;
            margin: 20px 0;
        }

        .stat-category {
            background: var(--white);
            border: 1px solid var(--gray-200);
            border-radius: 8px;
            padding: 20px;
        }

        .stat-category h5 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--navy);
            margin-bottom: 12px;
        }

        .stat-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .stat-item {
            background: var(--gray-100);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            color: var(--gray-700);
        }

        .stat-item.negative {
            background: #fef2f2;
            color: #991b1b;
        }

        /* Two column layout for methodology */
        .two-column {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 32px;
            margin: 24px 0;
        }

        .column-card {
            background: var(--white);
            border: 1px solid var(--gray-200);
            border-radius: 12px;
            padding: 24px;
        }

        .column-card h5 {
            font-size: 1.05rem;
            font-weight: 600;
            color: var(--navy);
            margin-bottom: 12px;
        }

        .column-card p {
            font-size: 0.95rem;
            margin-bottom: 12px;
        }

        .column-card ul {
            font-size: 0.95rem;
            margin-bottom: 0;
        }

        /* Tier cards */
        .tiers-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 32px;
            margin-top: 32px;
        }

        .tier-section-card {
            background: var(--white);
            border: 1px solid var(--gray-200);
            border-radius: 12px;
            padding: 28px;
        }

        .tier-section-card h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--navy);
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid var(--gray-200);
        }

        .tier-group {
            margin-bottom: 20px;
        }

        .tier-group:last-child {
            margin-bottom: 0;
        }

        .tier-label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .tier-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-weight: 700;
            font-size: 0.85rem;
            color: var(--white);
        }

        .tier-1 .tier-badge { background: linear-gradient(135deg, #fbbf24, #f59e0b); }
        .tier-2 .tier-badge { background: linear-gradient(135deg, #9ca3af, #6b7280); }
        .tier-3 .tier-badge { background: linear-gradient(135deg, #d97706, #b45309); }
        .tier-4 .tier-badge { background: var(--navy); }
        .tier-5 .tier-badge { background: var(--gray-500); }

        .tier-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--gray-700);
        }

        .teams-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .team-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: var(--gray-100);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--gray-700);
            transition: var(--transition);
        }

        .team-chip:hover {
            background: var(--gray-200);
        }

        .team-chip img {
            width: 20px;
            height: 20px;
            object-fit: contain;
        }

        /* Data tables */
        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
            flex-wrap: wrap;
            border-bottom: 1px solid var(--gray-200);
            padding-bottom: 8px;
        }

        .tab-btn {
            padding: 10px 20px;
            border: 1px solid var(--gray-200);
            background: var(--white);
            color: var(--gray-600);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: var(--transition);
        }

        .tab-btn:hover {
            background: var(--gray-50);
            color: var(--navy);
        }

        .tab-btn.active {
            background: var(--navy);
            border-color: var(--navy);
            color: var(--white);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .table-container {
            background: var(--white);
            border: 1px solid var(--gray-200);
            border-radius: 12px;
            overflow: hidden;
        }

        .table-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--gray-200);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }

        .table-header h4 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--gray-800);
        }

        .table-header p {
            font-size: 0.85rem;
            color: var(--gray-500);
            margin: 0;
        }

        .table-filter {
            padding: 8px 14px;
            border: 1px solid var(--gray-200);
            border-radius: 6px;
            font-size: 0.9rem;
            background: var(--white);
        }

        .table-filter:focus {
            outline: none;
            border-color: var(--navy);
        }

        .table-wrapper {
            overflow-x: auto;
            max-height: 500px;
            overflow-y: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        th, td {
            padding: 10px 12px;
            text-align: center;
            border-bottom: 1px solid var(--gray-100);
        }

        th {
            background: var(--gray-50);
            font-weight: 600;
            color: var(--gray-700);
            position: sticky;
            top: 0;
            white-space: nowrap;
        }

        td:first-child, th:first-child {
            position: sticky;
            left: 0;
            background: var(--white);
            font-weight: 600;
            z-index: 1;
            text-align: left;
        }

        th:first-child {
            background: var(--gray-50);
            z-index: 2;
        }

        tr:hover td {
            background: var(--gray-50);
        }

        tr:hover td:first-child {
            background: var(--gray-50);
        }

        .cell-high { background: rgba(34, 197, 94, 0.15); }
        .cell-mid { background: rgba(234, 179, 8, 0.15); }
        .cell-low { background: rgba(239, 68, 68, 0.1); }

        .team-cell {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .team-cell img {
            width: 20px;
            height: 20px;
            object-fit: contain;
        }

        /* Footer */
        .research-footer {
            margin-top: 60px;
            padding: 32px 0;
            background: var(--gray-50);
            border-top: 1px solid var(--gray-200);
        }

        .research-footer p {
            color: var(--gray-500);
            font-size: 0.9rem;
            text-align: center;
            margin-bottom: 8px;
        }

        .research-footer a {
            color: var(--navy);
            text-decoration: none;
        }

        .research-footer a:hover {
            text-decoration: underline;
        }

        /* Year selector */
        .year-selector-container {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 32px;
            flex-wrap: wrap;
        }

        .year-selector-label {
            font-weight: 600;
            color: var(--gray-700);
            font-size: 1rem;
        }

        .year-selector {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .year-btn {
            padding: 8px 16px;
            border: 1px solid var(--gray-200);
            background: var(--white);
            color: var(--gray-600);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: var(--transition);
        }

        .year-btn:hover {
            background: var(--gray-50);
            color: var(--navy);
            border-color: var(--navy);
        }

        .year-btn.active {
            background: var(--navy);
            border-color: var(--navy);
            color: var(--white);
        }

        /* Tier progression chart */
        .chart-container {
            position: relative;
            background: var(--white);
            border: 1px solid var(--gray-200);
            border-radius: 12px;
            padding: 28px;
            margin-top: 32px;
            overflow: hidden;
        }

        .chart-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .chart-controls label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--gray-600);
        }

        .side-toggle {
            display: flex;
            gap: 4px;
            background: var(--gray-100);
            border-radius: 6px;
            padding: 3px;
        }

        .side-toggle-btn {
            padding: 6px 16px;
            border: none;
            background: transparent;
            color: var(--gray-600);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: var(--transition);
        }

        .side-toggle-btn.active {
            background: var(--white);
            color: var(--navy);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .chart-canvas-wrapper {
            position: relative;
            width: 100%;
            overflow-x: auto;
        }

        #tierChart {
            display: block;
            min-width: 900px;
        }

        .replay-btn {
            padding: 8px 16px;
            border: 1px solid var(--gray-200);
            background: var(--white);
            color: var(--gray-600);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: var(--transition);
        }

        .replay-btn:hover {
            background: var(--gray-50);
            color: var(--navy);
            border-color: var(--navy);
        }

        @media (max-width: 768px) {
            .research-hero h1 {
                font-size: 1.75rem;
            }

            .two-column, .stat-grid {
                grid-template-columns: 1fr;
            }

            .tiers-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <a href="index.html" class="nav-logo">Jabari Myles</a>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">About</a></li>
                <li><a href="index.html#papers" class="nav-link">Research</a></li>
                <li><a href="index.html#projects" class="nav-link active">Projects</a></li>
                <li><a href="index.html#contact" class="nav-link">Contact</a></li>
            </ul>
            <button class="nav-toggle" aria-label="Toggle menu">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>
    </nav>

    <!-- Hero -->
    <header class="research-hero">
        <div class="container">
            <a href="index.html#projects" class="back-link">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
                Back to Projects
            </a>
            <h1>From Rankings to Tiers: NFL Team Clustering</h1>
            <p class="subtitle">Applying Cut Imbalance Clustering to NFL Team Performance Analysis</p>
            <p class="meta">2015–2025 Season Data | nflverse Play-by-Play Statistics</p>
        </div>
    </header>

    <main>
        <!-- Methodology Section -->
        <section class="section" id="methodology">
            <div class="container">
                <h2 class="section-title">Research Methodology</h2>

                <!-- Why Tiers -->
                <div class="methodology-section">
                    <h3>Why Tiers Instead of Rankings?</h3>
                    <p>
                        Traditional rankings assign a unique position to each item, but this level of granularity often
                        overstates our ability to distinguish between similar items. When comparing NFL teams, is the
                        difference between the 8th and 9th ranked team meaningful, or are they essentially equivalent?
                    </p>
                    <div class="highlight-box key-insight">
                        <p><strong>Key Insight:</strong> Tiering provides a more honest representation of comparative
                        relationships. Teams within the same tier are considered statistically indistinguishable, while
                        teams in different tiers show clear performance gaps.</p>
                    </div>
                    <p>
                        This approach is particularly valuable in sports analytics where noise, variance, and sample
                        size limitations make precise ordinal rankings unreliable. A tier-based system acknowledges
                        uncertainty while still providing actionable insights about team quality.
                    </p>
                </div>

                <!-- Cut Imbalance Clustering -->
                <div class="methodology-section">
                    <h3>Cut Imbalance Clustering</h3>
                    <p>
                        Cut imbalance clustering is a method for partitioning items into hierarchical tiers based on
                        pairwise preference data. The core idea comes from analyzing the "cuts" between adjacent tiers
                        in a partition.
                    </p>

                    <h4>The Intuition</h4>
                    <p>
                        Consider a partition of teams into tiers. For any two tiers, we can examine all pairwise
                        comparisons between teams across those tiers. If teams are correctly grouped:
                    </p>
                    <ul>
                        <li><strong>Within a tier:</strong> Comparisons should be roughly balanced (teams are similar)</li>
                        <li><strong>Across tiers:</strong> Comparisons should be imbalanced (higher tier teams dominate)</li>
                    </ul>

                    <div class="highlight-box">
                        <p><strong>Cut Imbalance Definition:</strong> The cut imbalance between two tiers measures the
                        net preference of the higher tier over the lower tier. A high cut imbalance indicates a clear
                        separation between tiers.</p>
                    </div>

                    <h4>Cumulative Cut Imbalance</h4>
                    <p>
                        For a partition into K tiers, the <em>cumulative cut imbalance</em> sums the imbalances across
                        all pairs of tiers. This serves as our objective as we seek the partition that
                        maximizes cumulative cut imbalance.
                    </p>
                    <div class="formula-box">
                        CI = &Sigma;<sub>k&lt;l</sub> &Sigma;<sub>i&isin;C<sub>k</sub>, j&isin;C<sub>l</sub></sub> (w<sub>ij</sub> - w<sub>ji</sub>)
                    </div>
                    <p>
                        Where w<sub>ij</sub> is the normalized preference of team i over team j, and C<sub>k</sub>
                        denotes the set of teams in tier k (with lower indices being higher/better tiers).
                    </p>
                </div>

                <!-- Preference Matrix -->
                <div class="methodology-section">
                    <h3>Preference Matrix Construction</h3>
                    <p>
                        The foundation of our analysis is a <em>preference matrix</em> W where entry w<sub>ij</sub>
                        represents how strongly team i is preferred over team j based on statistical comparisons.
                    </p>

                    <h4>Pairwise Stat Comparisons</h4>
                    <p>
                        For each pair of teams, we compare them across 10 key statistics. The raw preference count
                        is simply the number of stats where team i outperforms team j. We then normalize so that
                        w<sub>ij</sub> + w<sub>ji</sub> = 1 for all pairs.
                    </p>

                    <div class="stat-grid">
                        <div class="stat-category">
                            <h5>Offensive Statistics (10)</h5>
                            <div class="stat-list">
                                <span class="stat-item">Points Scored</span>
                                <span class="stat-item">Total Yards</span>
                                <span class="stat-item">Passing Yards</span>
                                <span class="stat-item">Rushing Yards</span>
                                <span class="stat-item">Yards Per Play</span>
                                <span class="stat-item">Completion %</span>
                                <span class="stat-item">Total TDs</span>
                                <span class="stat-item negative">Turnovers (lower)</span>
                                <span class="stat-item">3rd Down %</span>
                                <span class="stat-item">Red Zone TD %</span>
                            </div>
                        </div>
                        <div class="stat-category">
                            <h5>Defensive Statistics (10)</h5>
                            <div class="stat-list">
                                <span class="stat-item negative">Points Allowed</span>
                                <span class="stat-item negative">Yards Allowed</span>
                                <span class="stat-item negative">Pass Yds Allowed</span>
                                <span class="stat-item negative">Rush Yds Allowed</span>
                                <span class="stat-item negative">Yds/Play Allowed</span>
                                <span class="stat-item negative">TDs Allowed</span>
                                <span class="stat-item">Turnovers Forced</span>
                                <span class="stat-item">Sacks</span>
                                <span class="stat-item negative">3rd Down % Allowed</span>
                                <span class="stat-item negative">Red Zone % Allowed</span>
                            </div>
                        </div>
                    </div>
                    <p style="font-size: 0.9rem; color: var(--gray-500); margin-top: 8px;">
                        <em>Red items indicate "lower is better" statistics where the comparison direction is reversed.</em>
                    </p>

                    <h4>Normalization</h4>
                    <p>
                        Raw preference counts are normalized to ensure w<sub>ij</sub> + w<sub>ji</sub> = 1:
                    </p>
                    <div class="formula-box">
                        w<sub>ij</sub> = (raw count i beats j) / (raw count i beats j + raw count j beats i)
                    </div>
                    <p>
                        This normalization ensures the preference matrix captures relative strength. A value of
                        w<sub>ij</sub> = 0.7 means team i beats team j on 70% of their head-to-head stat comparisons.
                    </p>
                </div>

                <!-- PNoRanking Formulation -->
                <div class="methodology-section">
                    <h3>The PNoRanking Formulation</h3>
                    <p>
                        A key contribution of this research is the <strong>PNoRanking</strong> (Partition with No
                        Ranking) formulation, which finds optimal tiers <em>without requiring an initial ranking</em>
                        of items.
                    </p>

                    <div class="highlight-box key-insight">
                        <p><strong>Why This Matters:</strong> Traditional tiering methods first rank items, then
                        partition that ranking. PNoRanking jointly determines both the tier assignments and the
                        implicit tier ordering, avoiding bias from a potentially suboptimal initial ranking.</p>
                    </div>

                    <h4>Mixed Integer Linear Program (MILP)</h4>
                    <p>
                        The optimal clustering can be found exactly via a MILP formulation:
                    </p>
                    <div class="formula-box left-align">
                        <code>
maximize:  (1/2) * &Sigma;<sub>k&lt;l</sub> &Sigma;<sub>i&ne;j</sub> (w<sub>ij</sub> - w<sub>ji</sub>) * z<sub>ijkl</sub>

subject to:
    &Sigma;<sub>k</sub> x<sub>ik</sub> = 1          &forall; i     (each team in exactly one tier)

    z<sub>ijkl</sub> &le; x<sub>ik</sub>           &forall; i,j,k,l  (linearization)
    z<sub>ijkl</sub> &le; x<sub>jl</sub>           &forall; i,j,k,l
    z<sub>ijkl</sub> &ge; x<sub>ik</sub> + x<sub>jl</sub> - 1   &forall; i,j,k,l

    x<sub>ik</sub> &isin; {0,1}
    z<sub>ijkl</sub> &isin; {0,1}
                        </code>
                    </div>
                    <p>
                        Where x<sub>ik</sub> = 1 if team i is assigned to tier k, and z<sub>ijkl</sub> = 1 if team i
                        is in tier k AND team j is in tier l.
                    </p>

                    <h4>Coupled Probability Updating (Heuristic)</h4>
                    <p>
                        For larger instances where the MILP becomes computationally expensive, we use a
                        <em>Coupled Probability Updating</em> algorithm that iteratively refines soft cluster
                        assignments using simulated annealing:
                    </p>
                    <ol>
                        <li>Solve the LP relaxation, providing an initial probability distribution over every tier for each team</li>
                        <li>Compute contribution scores based on expected cut imbalance gains</li>
                        <li>Update probabilities via softmax with temperature annealing</li>
                        <li>Apply momentum to smooth updates and avoid oscillation</li>
                        <li>Periodically extract integer solutions and track the best</li>
                    </ol>
                </div>

                <!-- Selecting K -->
                <div class="methodology-section">
                    <h3>Selecting the Number of Tiers (K)</h3>
                    <p>
                        A key question in any clustering problem is: how many clusters (tiers) should we use?
                        The choice of K significantly impacts the results.
                    </p>
                    <div class="two-column">
                        <div class="column-card">
                            <h5>Too Few Tiers</h5>
                            <p>
                                If K is too small, we force dissimilar teams into the same tier, reducing within-tier
                                balance and leaving cut imbalance "on the table."
                            </p>
                        </div>
                        <div class="column-card">
                            <h5>Too Many Tiers</h5>
                            <p>
                                If K is too large, tiers become too granular. We may separate teams that are
                                statistically indistinguishable, and tiers may be nearly empty.
                            </p>
                        </div>
                    </div>

                    <h4>In This NFL Example</h4>
                    <p>
                        For this demonstration, we use a simplified approach: we test several values of K
                        (from 2 to 6), solve the clustering problem for each, and select the K that maximizes
                        cumulative cut imbalance. This grid search approach is practical for quick analyses
                        and works well when the range of reasonable K values is small.
                    </p>
                    <p>
                        For NFL seasons, we use <strong>K = 5 tiers</strong> for both
                        offense and defense to stratify team performance.
                    </p>

                    <div class="highlight-box key-insight">
                        <p><strong>In the Research Paper:</strong> The full paper presents a more rigorous
                        approach that <em>optimizes over all possible numbers of tiers simultaneously</em>.
                        Rather than fixing K and solving, we formulate an extended model where K itself becomes
                        a decision variable. This allows the algorithm to automatically discover the optimal
                        number of tiers without requiring a grid search, and provides theoretical guarantees
                        about the solution quality.</p>
                    </div>
                </div>

                <!-- Interpretation -->
                <div class="methodology-section">
                    <h3>Interpreting the Results</h3>
                    <p>
                        The resulting tiers should be interpreted as follows:
                    </p>
                    <ul>
                        <li><strong>Teams in the same tier</strong> are statistically similar; pairwise comparisons
                        between them are relatively balanced</li>
                        <li><strong>Teams in different tiers</strong> show clear separation; higher tier teams
                        consistently outperform lower tier teams across the stat comparisons</li>
                        <li><strong>Tier ordering</strong> is determined by dominance; Tier 1 teams dominate
                        all other tiers, Tier 2 teams dominate Tiers 3+, etc.</li>
                    </ul>
                    <div class="highlight-box">
                        <p><strong>Note:</strong> Offense and defense are tiered separately because a team's offensive
                        strength may differ significantly from its defensive strength.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Results Section -->
        <section class="section section-alt" id="results">
            <div class="container">
                <h2 class="section-title">Season Tier Results</h2>
                <p class="section-subtitle">
                    Teams clustered into tiers based on offensive and defensive performance across the season.
                </p>

                <div class="year-selector-container">
                    <span class="year-selector-label">Season:</span>
                    <div class="year-selector" id="year-selector"></div>
                </div>

                <div class="tiers-container">
                    <div class="tier-section-card">
                        <h3>Offensive Tiers</h3>
                        <div id="offense-tiers"></div>
                    </div>

                    <div class="tier-section-card">
                        <h3>Defensive Tiers</h3>
                        <div id="defense-tiers"></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Tier Progression Chart -->
        <section class="section" id="progression">
            <div class="container">
                <h2 class="section-title">Tier Progression</h2>
                <p class="section-subtitle">
                    How each team's tier has changed across seasons (2015–2025).
                </p>

                <div class="chart-container">
                    <div class="chart-controls">
                        <div class="side-toggle">
                            <button class="side-toggle-btn active" data-side="offense">Offense</button>
                            <button class="side-toggle-btn" data-side="defense">Defense</button>
                        </div>
                        <select class="table-filter" id="division-select"></select>
                        <button class="replay-btn" id="replay-btn">Replay Animation</button>
                    </div>
                    <div class="chart-canvas-wrapper">
                        <canvas id="tierChart" width="1100" height="420"></canvas>
                    </div>
                </div>
            </div>
        </section>

        <!-- Interactive Data Section -->
        <section class="section" id="data">
            <div class="container">
                <h2 class="section-title">Preference Matrices</h2>
                <p class="section-subtitle">
                    Explore the raw pairwise preference data underlying the tier assignments.
                </p>

                <div class="tabs">
                    <button class="tab-btn active" data-tab="pref-offense">Offensive Preferences</button>
                    <button class="tab-btn" data-tab="pref-defense">Defensive Preferences</button>
                </div>

                <!-- Offense Matrix Tab -->
                <div id="pref-offense" class="tab-content active">
                    <div class="table-container">
                        <div class="table-header">
                            <div>
                                <h4>Offensive Preference Matrix</h4>
                                <p>Entry (i, j) = number of offensive stats where row team i outperforms column team j (out of 10)</p>
                            </div>
                            <input type="text" class="table-filter" id="filter-offense" placeholder="Filter teams...">
                        </div>
                        <div class="table-wrapper">
                            <table id="offense-matrix-table">
                                <thead></thead>
                                <tbody></tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Defense Matrix Tab -->
                <div id="pref-defense" class="tab-content">
                    <div class="table-container">
                        <div class="table-header">
                            <div>
                                <h4>Defensive Preference Matrix</h4>
                                <p>Entry (i, j) = number of defensive stats where row team i outperforms column team j (out of 10)</p>
                            </div>
                            <input type="text" class="table-filter" id="filter-defense" placeholder="Filter teams...">
                        </div>
                        <div class="table-wrapper">
                            <table id="defense-matrix-table">
                                <thead></thead>
                                <tbody></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer class="research-footer">
        <div class="container">
            <p>Data Source: <a href="https://github.com/nflverse" target="_blank">nflverse</a> Play-by-Play Data (2015–2025 Seasons)</p>
            <p>Methodology: "From Rankings to Tiers: Cut Imbalance Clustering" (Myles et al.)</p>
        </div>
    </footer>

    <script>
        // --- Data (loaded from JSON files) ---
        let allTiers = {};
        let allMatrices = {};
        let currentYear = 2024;
        let chartSide = 'offense';

        const teamLogoMap = {
            "ARI": "ari", "ATL": "atl", "BAL": "bal", "BUF": "buf",
            "CAR": "car", "CHI": "chi", "CIN": "cin", "CLE": "cle",
            "DAL": "dal", "DEN": "den", "DET": "det", "GB": "gb",
            "HOU": "hou", "IND": "ind", "JAX": "jax", "KC": "kc",
            "LA": "lar", "LAC": "lac", "LV": "lv", "MIA": "mia",
            "MIN": "min", "NE": "ne", "NO": "no", "NYG": "nyg",
            "NYJ": "nyj", "PHI": "phi", "PIT": "pit", "SEA": "sea",
            "SF": "sf", "TB": "tb", "TEN": "ten", "WAS": "wsh"
        };

        const teamColors = {
            "ARI": "#97233F", "ATL": "#A71930", "BAL": "#241773", "BUF": "#00338D",
            "CAR": "#0085CA", "CHI": "#C83803", "CIN": "#FB4F14", "CLE": "#311D00",
            "DAL": "#003594", "DEN": "#FB4F14", "DET": "#0076B6", "GB": "#203731",
            "HOU": "#03202F", "IND": "#002C5F", "JAX": "#006778", "KC": "#E31837",
            "LA": "#003594", "LAC": "#0080C6", "LV": "#000000", "MIA": "#008E97",
            "MIN": "#4F2683", "NE": "#002244", "NO": "#D3BC8D", "NYG": "#0B2265",
            "NYJ": "#125740", "PHI": "#004C54", "PIT": "#FFB612", "SEA": "#002244",
            "SF": "#AA0000", "TB": "#D50A0A", "TEN": "#4B92DB", "WAS": "#773141"
        };

        const tierNames = { 1: "Elite", 2: "Great", 3: "Good", 4: "Below Avg", 5: "Bottom" };

        const divisions = {
            "AFC East": ["BUF", "MIA", "NE", "NYJ"],
            "AFC North": ["BAL", "CIN", "CLE", "PIT"],
            "AFC South": ["HOU", "IND", "JAX", "TEN"],
            "AFC West": ["DEN", "KC", "LAC", "LV"],
            "NFC East": ["DAL", "NYG", "PHI", "WAS"],
            "NFC North": ["CHI", "DET", "GB", "MIN"],
            "NFC South": ["ATL", "CAR", "NO", "TB"],
            "NFC West": ["ARI", "LA", "SEA", "SF"]
        };
        let currentDivision = "AFC East";

        function getLogoUrl(team) {
            const code = teamLogoMap[team] || team.toLowerCase();
            return `https://a.espncdn.com/i/teamlogos/nfl/500/${code}.png`;
        }

        // --- Year Selector ---
        function buildYearSelector() {
            const container = document.getElementById('year-selector');
            const years = Object.keys(allTiers).map(Number).sort();
            container.innerHTML = years.map(y =>
                `<button class="year-btn${y === currentYear ? ' active' : ''}" data-year="${y}">${y}</button>`
            ).join('');

            container.addEventListener('click', (e) => {
                const btn = e.target.closest('.year-btn');
                if (!btn) return;
                currentYear = parseInt(btn.dataset.year);
                container.querySelectorAll('.year-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                renderTierCards();
                renderMatrices();
            });
        }

        // --- Tier Cards ---
        function renderTierCards() {
            const offenseContainer = document.getElementById('offense-tiers');
            const defenseContainer = document.getElementById('defense-tiers');
            const yearData = allTiers[currentYear];
            if (!yearData) return;

            const offenseTiers = {}, defenseTiers = {};
            Object.entries(yearData).forEach(([team, tiers]) => {
                if (!offenseTiers[tiers.offense]) offenseTiers[tiers.offense] = [];
                if (!defenseTiers[tiers.defense]) defenseTiers[tiers.defense] = [];
                offenseTiers[tiers.offense].push(team);
                defenseTiers[tiers.defense].push(team);
            });

            function renderTiers(container, tiersData) {
                container.innerHTML = '';
                Object.keys(tiersData).sort((a, b) => a - b).forEach(tierNum => {
                    const teams = tiersData[tierNum];
                    const tierDiv = document.createElement('div');
                    tierDiv.className = `tier-group tier-${tierNum}`;
                    tierDiv.innerHTML = `
                        <div class="tier-label">
                            <span class="tier-badge">${tierNum}</span>
                            <span class="tier-name">${tierNames[tierNum] || `Tier ${tierNum}`}</span>
                        </div>
                        <div class="teams-row">
                            ${teams.map(team => `
                                <div class="team-chip">
                                    <img src="${getLogoUrl(team)}" alt="${team}" onerror="this.style.display='none'">
                                    <span>${team}</span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    container.appendChild(tierDiv);
                });
            }

            renderTiers(offenseContainer, offenseTiers);
            renderTiers(defenseContainer, defenseTiers);
        }

        // --- Preference Matrices ---
        function renderMatrices() {
            const yearMatrices = allMatrices[currentYear];
            if (!yearMatrices) return;
            renderMatrixTable('offense-matrix-table', yearMatrices.offense, 'filter-offense');
            renderMatrixTable('defense-matrix-table', yearMatrices.defense, 'filter-defense');
        }

        function renderMatrixTable(tableId, matrix, filterId) {
            const table = document.getElementById(tableId);
            const teams = Object.keys(matrix).sort();

            const thead = table.querySelector('thead');
            thead.innerHTML = `<tr><th>Team</th>${teams.map(t => `<th>${t}</th>`).join('')}</tr>`;

            const tbody = table.querySelector('tbody');

            function renderRows(filterText = '') {
                const filtered = filterText ? teams.filter(t => t.toLowerCase().includes(filterText.toLowerCase())) : teams;
                tbody.innerHTML = filtered.map(rowTeam => `
                    <tr>
                        <td>
                            <div class="team-cell">
                                <img src="${getLogoUrl(rowTeam)}" onerror="this.style.display='none'">
                                ${rowTeam}
                            </div>
                        </td>
                        ${teams.map(colTeam => {
                            const val = matrix[rowTeam][colTeam];
                            let cellClass = '';
                            if (rowTeam !== colTeam) {
                                if (val >= 7) cellClass = 'cell-high';
                                else if (val >= 4) cellClass = 'cell-mid';
                                else cellClass = 'cell-low';
                            }
                            return `<td class="${cellClass}">${val}</td>`;
                        }).join('')}
                    </tr>
                `).join('');
            }

            renderRows();
            const filterEl = document.getElementById(filterId);
            // Remove old listeners by cloning
            const newFilter = filterEl.cloneNode(true);
            filterEl.parentNode.replaceChild(newFilter, filterEl);
            newFilter.addEventListener('input', (e) => renderRows(e.target.value));
        }

        // --- Animated Tier Progression Chart ---
        const logoImages = {};
        let logoLoadCount = 0;
        const allTeams = Object.keys(teamColors).sort();

        function preloadLogos(callback) {
            let loaded = 0;
            allTeams.forEach(team => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => { logoImages[team] = img; loaded++; if (loaded === allTeams.length) callback(); };
                img.onerror = () => { loaded++; if (loaded === allTeams.length) callback(); };
                img.src = getLogoUrl(team);
            });
        }

        function buildDivisionSelect() {
            const select = document.getElementById('division-select');
            select.innerHTML = Object.keys(divisions).map(div =>
                `<option value="${div}"${div === currentDivision ? ' selected' : ''}>${div}</option>`
            ).join('');
            select.addEventListener('change', (e) => {
                currentDivision = e.target.value;
                drawTierChart(true);
            });
        }

        function drawTierChart(animate = true) {
            const canvas = document.getElementById('tierChart');
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;

            const W = 1100, H = 420;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            canvas.style.width = W + 'px';
            canvas.style.height = H + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            const years = Object.keys(allTiers).map(Number).sort();
            const marginLeft = 55, marginRight = 80, marginTop = 40, marginBottom = 40;
            const plotW = W - marginLeft - marginRight;
            const plotH = H - marginTop - marginBottom;

            const maxTier = 5;
            const xStep = plotW / (years.length - 1);
            const yStep = plotH / (maxTier - 1);

            function getX(i) { return marginLeft + i * xStep; }
            function getY(tier) { return marginTop + (tier - 1) * yStep; }

            // Build series for current division only
            const divTeams = divisions[currentDivision] || [];
            const series = divTeams.map(team => {
                const points = years.map((yr, i) => {
                    const td = allTiers[yr];
                    if (!td || !td[team]) return null;
                    const tier = chartSide === 'offense' ? td[team].offense : td[team].defense;
                    return { x: getX(i), y: getY(tier), tier };
                });
                return { team, points, color: teamColors[team] };
            });

            function renderFrame(progress) {
                ctx.clearRect(0, 0, W, H);

                // Background
                ctx.fillStyle = '#fafafa';
                ctx.fillRect(0, 0, W, H);

                // Grid lines and tier labels
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 1;
                ctx.font = '13px system-ui, sans-serif';
                ctx.fillStyle = '#6b7280';
                ctx.textAlign = 'right';
                for (let t = 1; t <= maxTier; t++) {
                    const y = getY(t);
                    ctx.beginPath();
                    ctx.setLineDash([4, 4]);
                    ctx.moveTo(marginLeft, y);
                    ctx.lineTo(W - marginRight, y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.fillText(`Tier ${t}`, marginLeft - 10, y + 5);
                }

                // Year labels
                ctx.textAlign = 'center';
                ctx.fillStyle = '#6b7280';
                ctx.font = '12px system-ui, sans-serif';
                years.forEach((yr, i) => {
                    ctx.fillText(yr, getX(i), H - marginBottom + 20);
                });

                // Draw lines
                const totalSegments = years.length - 1;
                const segmentsToShow = progress * totalSegments;

                series.forEach(({ team, points, color }) => {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.globalAlpha = 0.9;
                    ctx.beginPath();

                    let tipX = null, tipY = null;
                    for (let i = 0; i < points.length - 1; i++) {
                        if (i >= segmentsToShow) break;
                        const p1 = points[i];
                        const p2 = points[i + 1];
                        if (!p1 || !p2) continue;

                        const segProgress = Math.min(1, segmentsToShow - i);

                        if (i === 0 || !points[i - 1]) {
                            ctx.moveTo(p1.x, p1.y);
                            if (tipX === null) { tipX = p1.x; tipY = p1.y; }
                        }

                        tipX = p1.x + (p2.x - p1.x) * segProgress;
                        tipY = p1.y + (p2.y - p1.y) * segProgress;
                        ctx.lineTo(tipX, tipY);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;

                    // If no segments drawn yet, show logo at first point
                    if (tipX === null && points[0]) {
                        tipX = points[0].x;
                        tipY = points[0].y;
                    }

                    // Draw logo at current tip position
                    if (tipX !== null && logoImages[team]) {
                        const logoSize = 28;
                        ctx.drawImage(logoImages[team], tipX + 10, tipY - logoSize / 2, logoSize, logoSize);
                    }
                });

                // Draw dots at data points
                series.forEach(({ team, points, color }) => {
                    ctx.fillStyle = color;
                    for (let i = 0; i <= Math.min(Math.floor(segmentsToShow), points.length - 1); i++) {
                        const p = points[i];
                        if (!p) continue;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    if (progress >= 1 && points[points.length - 1]) {
                        const p = points[points.length - 1];
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }

            if (animate) {
                const duration = 6000;
                const start = performance.now();
                function step(ts) {
                    const elapsed = ts - start;
                    const progress = Math.min(elapsed / duration, 1);
                    // Linear pacing with slight hesitation at each year
                    const totalSegs = years.length - 1;
                    const raw = progress * totalSegs;
                    const seg = Math.floor(raw);
                    const segFrac = raw - seg;
                    // Ease each segment individually (slow start, snap into place)
                    const easedFrac = segFrac < 0.15 ? 0 : Math.pow((segFrac - 0.15) / 0.85, 0.6);
                    const eased = (seg + easedFrac) / totalSegs;
                    renderFrame(eased);
                    if (progress < 1) requestAnimationFrame(step);
                }
                requestAnimationFrame(step);
            } else {
                renderFrame(1);
            }
        }

        // --- Tab switching ---
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById(btn.dataset.tab).classList.add('active');
            });
        });

        // --- Chart controls ---
        document.querySelectorAll('.side-toggle-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.side-toggle-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                chartSide = btn.dataset.side;
                drawTierChart(true);
            });
        });

        document.getElementById('replay-btn').addEventListener('click', () => {
            drawTierChart(true);
        });

        // --- Mobile nav ---
        const navToggle = document.querySelector('.nav-toggle');
        const navMenu = document.querySelector('.nav-menu');
        navToggle.addEventListener('click', () => {
            navMenu.classList.toggle('active');
            navToggle.classList.toggle('active');
        });

        // --- Initialize ---
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                const [tiersRes, matricesRes] = await Promise.all([
                    fetch('team_tiers_all.json'),
                    fetch('preference_matrices_all.json')
                ]);
                allTiers = await tiersRes.json();
                allMatrices = await matricesRes.json();
            } catch (e) {
                console.error('Failed to load data files:', e);
                return;
            }

            buildYearSelector();
            buildDivisionSelect();
            renderTierCards();
            renderMatrices();
            preloadLogos(() => drawTierChart(true));
        });
    </script>
</body>
</html>
